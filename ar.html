<!--
  "ar_with_alvaAR.html"
  Integrated Roots & Routes AR scene that replaces the GPS‑driven camera
  with an AlvaAR WebAssembly SLAM camera for sub‑meter tracking.
  ▸ drop alva_ar.js + alva_ar.wasm in the same directory after you build them
  ▸ keep your existing CSV, plant models and index.html calibration page
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Roots & Routes – AR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

    <!-- A‑Frame & AR.js (latest stable) -->
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.5.0/dist/aframe.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/aframe-look-at-component@0.9.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-gps-camera@1.10.4/dist/aframe-gps-camera.min.js"></script>

    <!-- AlvaAR (built separately) -->
    <script type="module" src="./alva_ar.js"></script>
    <style>
        body,
        html {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        #plant-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, .75);
            color: #fff;
            border-radius: 8px;
            font-family: system-ui, sans-serif;
            display: none;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>

<body>
    <!-- info pop‑up -->
    <div id="plant-info"></div>

    <a-scene embedded renderer="antialias:true" vr-mode-ui="enabled:false" cursor="rayOrigin:mouse">
        <!-- SLAM‑driven camera -->
        <a-camera id="cam" slam-camera gps-projected-camera="gpsMinDistance:3"></a-camera>
    </a-scene>

    <script type="module">
        /* ------------------------------------------------------------------
         * 1 · SLAM‑CAMERA COMPONENT  – feeds video frames to AlvaAR and drives
         *                             the <a-camera>'s pose each animation frame
         * ------------------------------------------------------------------ */
        import { AlvaAR } from './alva_ar.js';
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.2/build/three.module.js";

        AFRAME.registerComponent('slam-camera', {
            schema: { gpsAlignAccuracy: { type: 'number', default: 10 } },
            async init() {
                const el = this.el;

                /* 1. Spin up rear camera stream */
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } } });
                this.video = document.createElement('video');
                Object.assign(this.video, { autoplay: true, muted: true, playsInline: true });
                this.video.srcObject = stream;
                await this.video.play();

                /* 2. Allocate an off‑screen canvas matching the feed */
                this.canvas = Object.assign(document.createElement('canvas'), { width: this.video.videoWidth, height: this.video.videoHeight });
                this.ctx = this.canvas.getContext('2d');

                /* 3. Init AlvaAR WASM */
                this.alva = await AlvaAR.Initialize(this.canvas.width, this.canvas.height);

                /* 4. Set up matrices */
                this.tmpMatrix = new THREE.Matrix4();
                this.worldOffset = new THREE.Matrix4();   // filled once GPS tie‑point acquired

                /* 5. Take the first accurate GPS fix to anchor worldOffset */
                navigator.geolocation.getCurrentPosition(pos => {
                    const { latitude, longitude, accuracy } = pos.coords;
                    if (accuracy > this.data.gpsAlignAccuracy) return;  // wait for a better fix
                    // Convert lat/lon to projected metres using the same helper as aframe‑gps
                    const scale = 111319.9; // rough metres/deg at equator; fine for small sites
                    this.worldOffset.makeTranslation(
                        -(longitude * scale), 0, -(latitude * scale)   // negative so world origin == tie‑point
                    );
                }, console.error, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });

                console.log('[slam‑camera] initialised');
            },
            tick() {
                if (!this.alva) return;

                /* grab frame → pose */
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const pose = this.alva.findCameraPose(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
                if (!pose) return;

                /* apply world offset and update the <a-camera> object3D */
                this.tmpMatrix.fromArray(pose).premultiply(this.worldOffset);
                const obj = this.el.object3D;
                this.tmpMatrix.decompose(obj.position, obj.quaternion, obj.scale);
            }
        });
        /* ------------------------------------------------------------------
         * 2 · PLANT MARKER LOGIC  – copies your existing code almost verbatim
         * ------------------------------------------------------------------ */
        const plantInfoDisplay = document.getElementById('plant-info');

        const scene = document.querySelector('a-scene');
        const cam = document.getElementById('cam');
        let plantCache = {};

        // watch GPS purely to know where the user is & filter nearby plants
        navigator.geolocation.watchPosition(pos => {
            const { latitude, longitude } = pos.coords;
            updatePlantMarkers(latitude, longitude);
        }, console.error, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });

        function updatePlantMarkers(userLat, userLon) {
            fetch('./ABG.csv')
                .then(r => r.text())
                .then(csv => {
                    const plants = parseCSV(csv)
                        .map(p => ({ ...p, distance: getDistance(userLat, userLon, p.lat, p.lon) }))
                        .filter(p => p.distance <= 10)
                        .sort((a, b) => a.distance - b.distance)
                        .slice(0, 10);

                    plants.forEach(plant => {
                        if (plantCache[plant.s_id]) {
                            plantCache[plant.s_id].setAttribute('gps-projected-entity-place', `latitude:${plant.lat}; longitude:${plant.lon}`);
                        } else {
                            const hScale = getScaleFromHeight(plant.height);
                            const marker = document.createElement('a-entity');
                            marker.setAttribute('gltf-model', getPolyModelURL(plant.height));
                            marker.setAttribute('scale', hScale);
                            marker.setAttribute('look-at', '#cam');
                            marker.setAttribute('gps-projected-entity-place', `latitude:${plant.lat}; longitude:${plant.lon}`);
                            marker.setAttribute('class', 'clickable');
                            marker.addEventListener('click', () => showPlantInfo(plant));
                            scene.appendChild(marker);
                            plantCache[plant.s_id] = marker;
                        }
                    });
                    // remove outdated markers
                    Object.keys(plantCache).forEach(id => {
                        if (!plants.find(p => p.s_id === id)) {
                            scene.removeChild(plantCache[id]);
                            delete plantCache[id];
                        }
                    });
                });
        }

        function showPlantInfo(plant) {
            plantInfoDisplay.innerHTML = `<strong>${plant.cname2 ? plant.cname2 + ', ' : ''}${plant.cname1 || ''}</strong><br>
    Genus: ${plant.genus || 'N/A'} &nbsp;Species: ${plant.species || 'N/A'}`;
            plantInfoDisplay.style.display = 'block';
            setTimeout(() => plantInfoDisplay.style.display = 'none', 3000);
        }

        // --- utility helpers (unchanged from your code) -------------------
        function parseCSV(csvText) {
            const rows = csvText.split('\n').slice(1);
            return rows.map(r => {
                const c = r.split(',');
                while (c.length < 11) c.push('');
                return {
                    s_id: c[0]?.trim(), cname1: c[1]?.trim() || 'Unknown', cname2: c[2]?.trim() || '',
                    cname3: c[3]?.trim() || '', genus: c[4]?.trim() || 'Unknown', species: c[5]?.trim() || '',
                    cultivar: c[6]?.trim() || '', lon: parseFloat(c[7]) || 0, lat: parseFloat(c[8]) || 0,
                    height: parseFloat(c[10]) || 1
                };
            })
                .filter(p => p.s_id && p.lat && p.lon);
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3, φ1 = lat1 * Math.PI / 180, φ2 = lat2 * Math.PI / 180,
                Δφ = (lat2 - lat1) * Math.PI / 180, Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) ** 2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function getPolyModelURL(h) {
            if (h <= 1) return './models/Shrub.glb';
            if (h <= 1.5) return './models/Bush.glb';
            if (h < 3) return './models/SmallTree.glb';
            if (h <= 4.5) return './models/Tree.glb';
            return './models/BigTree.glb';
        }
        function getScaleFromHeight(h) {
            if (h <= 1) return '1 1 1';
            if (h <= 1.5) return '1.5 1.5 1.5';
            if (h < 3) return '2 2 2';
            if (h <= 4.5) return '2.2 2.2 2.2';
            return '2.4 2.4 2.4';
        }
    </script>
</body>

</html>